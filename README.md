# 1. Describe the stack you’d use to build this app and why you’d choose these technologies over others

## Back-end:

### Node

Node is an incredibly powerful and versatile programming language. Documentation is abundant and setting up new projects with Node is efficient and straightforward. I enjoy working with Node when I am utilizing JavaScript for front-end development, as it establishes consistency between the two sides of the application.

### TypeScript

TypeScript enforces strict, descriptive patterns which enhance readability and maintainability, empowering teams to stay organized and productive. TypeScript helps to ensure code integrity by catching inconsistencies and promoting best-practices for clarity, organization and overall design.

### Vercel Functions

This decision is related to my choice to use NextJS for the front-end of the application. NextJS is developed by Vercel, which provides a serverless architecture for micro-services. An application of this scale does not require much in the way of computing resources, and a micro-service design enables future developments to take place without disrupting the codebase, while also providing a level of abstraction in the event the services must be switched to a different cloud provider.

### NextAuth

NextAuth supports OAuth 2.0 and OpenID, as well as previous solutions such as OAuth 1.0. This open-source authentication solution is designed to integrate seamlessly with NextJS applications, providing support for popular SSO services including, among others, Google and Twitter. This tool does not require a self-managed database for implementation, though that feature is optional with support for most popular databases.

### Prisma

Prisma is a powerful ORM built for Node and TypeScript. This utility makes creating and maintaining databases painless, making schema-definitions a breeze and removing the headache from database migrations. Prisma offers a very intuitive API for creating, accessing and updating data in a number of popular databases.

### MongoDB

An application such as this may have future developments based on how it is used and how the scope of requirements evolve. For this reason, its database should be adaptable to unknowns while remaining performant and scalable. MongoDB is fast and efficient, easy to organize and fully set up for both vertical and horizontal scaling.

### Jest

Jest, as a standalone testing solution, requires minimal configuration in an application. It supports isolation and auto-mocking and is very fast. Jest also supports asynchronous testing.

## Front-end:

### NextJS

NextJS is a powerful front-end framework built on React. NextJS provides server-side-rendering (for performance and SEO), static-site-generation so that pages can be cached, pre-rendering, build-size optimization and automatic code-splitting. Case in point: NextJS is fast. There also exist many UI libraries written for, or compatible with, NextJS, making the process of developing a clean, intuitive front-end application simple. NextJS can also take advantage of Vercel Functions, a serverless architecture provided by Vercel, the team behind NextJS.

### TypeScript

TypeScript enforces strict, descriptive patterns which enhance readability and maintainability, empowering teams to stay organized and productive. TypeScript helps to ensure code integrity by catching inconsistencies and promoting best-practices for clarity, organization and overall design.

### Context API

State management is critical in any application. Context API is React’s built-in state management solution, managing state at the component-level. Context API is fast and powerful, and negates the need for a third-party state management tool such as Redux. There are times when an abstracted, global state may be preferable, but for the purposes of this application, Context API will be more than enough.

### TailwindCSS

Tailwind is a powerful CSS framework providing out-of-the-box styles for commonly used components, as well as full customizability. Many modern UI libraries are built on Tailwind, making it an excellent solution for developing an intuitive, appealing front-end application.

# 2. Detail the database schema you would use to represent all of the data displayed in the wireframes (hint: keep it simple!)

### User:

- **id:** unique string, ObjectID generated by MongoDB
- **email:** unique string
- **password:** encrypted hash
- **name:** string
- **address:** stores user’s address and any relevant instructions (e.g. gate code)
- **dogs:** an array of the user’s dogs
- **bookings:** an array of the user’s bookings

### Dog:

- **id:** unique string, ObjectID generated by MongoDB
- **name:** string
- **breed:** string
- **avatar:** string, containing the URL to the dog’s photo
- **user:** a relation to the User who owns the dog

### Booking:

- **id:** unique string, ObjectID generated by MongoDB
- **cancelled:** boolean, indicates whether booking has been cancelled, defaults to “false”
- **user:** a relation to the User who booked the session
- **date:** DateTime (ISO string), this field is unique because we do not allow more than 1 booking per hour
- **dog:** a relation to the Dog who will utilize the session

```graphql
model User {                                                                                                                              
  id            String    @id   @default(auto()) @map(“_id”)    @db.ObjectId                                                      
  email         String    @unique                                                                                                            
  phone         String                                                                                                                   
  password      String                                                                                                                     
  name          String                                                                                                                     
  address       Address                                                                                                                     
  dogs          Dog[]                                                                                                                     
  bookings      Booking[]                                                                                                                     
}
```                                                                                                                                          
```graphql
model Dog {                                                                                                                                  
  id            String    @id   @default(auto()) @map("_id")    @db.ObjectId                                                      
  name          String                                                                                                                              
  breed         String                                                                                                                              
  avatar        String                                                                                                                                                                                                      
  user          User      @relation(fields: [userID], references: [id])                                                                                                                                                                                   
  userID        String    @db.ObjectId    @unique                                                                                                                                                                            
  booking       Booking?                                                                                                                  
}
```
```graphql
type Address {                                                                                                                              
  instructions  String?                                                                                                                              
  street1       String                                                                                                                              
  street2       String?                                                                                                                              
  city          String                                                                                                                              
  state         String                                                                                                                              
  zip           String                                                                                                                              
}                                                                                                            
```
```graphql
model Booking {                                                                                                                              
  id            String    @id   @default(auto()) @map("_id")    @db.ObjectId                                                                                                                                                                         
  cancelled     Boolean   @default(false)                                                      
  user          User      @relation(fields: [userID], references: [id])                                                                                                                                               
  userID        String    @db.ObjectId    @unique                                                      
  date          DateTime  @unique                                                                                                                            
  dog           Dog       @relation(fields: [dogID], references: [id])                                                                                                                                                               
  dogID         String    @db.ObjectId    @unique                                                      
}                                                                                                            
```

# 3. What does the API layer between the front and back end look like? Which routes are needed to display all the data in the wireframes and handle all potential actions?

The API layer will consist of serverless functions, each handling RESTful actions for its endpoint. The architecture could look like this:

```
/api
   ↳ /users
   |  ├ /get-users.controller.ts
   |  ├ /post-users.controller.ts
   |  └ /put-users.controller.ts
   ↳ /dogs
   |  ├ /get-dogs.controller.ts
   |  ├ /post-dogs.controller.ts
   |  ├ /put-dogs.controller.ts
   |  └ /delete-dogs.controller.ts
   ↳ /calendar
   |  └ /get-calendar.controller.ts
   ↳ /bookings
    | ├ /get-bookings.controller.ts
    | ├ /post-bookings.controller.ts
      └ /put-bookings.controller.ts
```
The endpoints are defined below:
| Method | Endpoint | Description | Params |
| ------ | -------- | ----------- | ------ |
| GET | /user | View Profile details |
| POST | /user | Create account |
| PUT | /user | Edit personal details |
| GET | /dogs | Fetch Dog details (no pun intended) |
| GET | /dogs/:id | Fetch details for specific Dog |
| POST | /dogs | Add a new Dog |
| PUT | /dogs/:id | Update a specific Dog’s information |
| DELETE | /dogs/:id | Remove a specific Dog from profile |
| GET | /calendar | Get the calendar on the current date | ?date: ISO string |
| GET | /bookings | View open bookings  ?date: ISO string |
| POST | /bookings | Create a new booking |
| PUT | /bookings/:id | Update a booking (useful for cancellation) | |

# 4. Write a React or React Native component for a row in the calendar that handles the various states it can be in (available, booked with someone else’s dog, booked with your dog)

## *Actual implementation available [here\*](src/components/schedule.tsx#L86)*
> *I left the `ScheduleRow` component in a file with other relevant components that work together to construct the schedule's list view. This should provide context for why I constructed the component the way I did.

I will make a few assumptions for this component:

There is a separate, imported component that shows up once a user has tapped the “Book” button. This component is a form that allows the user to select one of the dogs in their profile to schedule for the walk.
I am managing the user’s authentication in Context API, accessing their session token from a context object named “authCtx”
Any current booking for this particular time slot is passed into the component; if there is no booking, the property is not passed in
The date for this time slot is passed in as an ISO string
I will write the cancellation service here, though normally I would abstract that service to its own hook

```typescript
import { useCallback, useContext, useState } from ‘react’                                                                          
import { authCtx } from ‘../auth’                                                                                                           
import BookingForm from ‘../booking/Form’                                                        
                                                                                        
export const CalendarRow = ({ booking, date }: CalendarRowProps) => {                                                                                 
  const [bookSession, setBookSession] = useState<boolean>(false)                       
  const { authenticatedUser } = useContext(authCtx)                                              
  const timeString = (new Date(date)).toLocaleTimeString('en-US', {                                                                                                                                                                                                                                               
    hour: '2-digit',                                                                        
  })                                                                                                                                                                                                                                                                                            
                                                                                                                                                     
  const handleCancel = useCallback(async () => {                                                                        
    await fetch(`/bookings/${booking?.id}`, {                                                                        
      method: 'PUT',                                                                        
      headers: {                                                                        
        'Authorization': `Bearer ${authenticatedUser.sessionToken}`,                                                                                                                                                                                               
        'Content-Type': 'application/json',                                                                        
      },                                                                                                                                                
      body: JSON.stringify({                                                                        
        cancel: true,                                                                        
      }),                                                                                                                                                
    })                                                                                                                                                
  }, [booking])                                                                                                                                                
                                                                                                                                                
  return (                                                                                                                                                
    <div className="calendar__row">                                                                        
      <div>                                                                                                                                                
        {bookSession && (                                                                        
          <BookingForm date={date} />                                                                        
        )}                                                                                                                                                
        <time datetime={date}>{timeString}</time>                                                                        
        {!booking && (                                                                        
          <button onClick={() => setBookSession(true)}>Book</button>                                                                                                                                                                                                                                        
        )}                                                                                                                                                
        {booking && booking.userID !== authenticatedUser.id && (                                                                        
          <button disabled={true}>Booked</button>                                                                        
        )}                                                                                                                                                
        {booking && booking.userID === authenticatedUser.id && (                                                                        
          <button onClick={handleCancel}>Cancel</button>                                                                        
        )}                                                                                                                                                
      </div>                                                                                                                                                
      {booking && booking.userID === authenticatedUser.id && (                                                                        
        <div className="booking__details">                                                                        
          <img src={booking.dog.avatar} alt={booking.dog.name} />                                                                                                                                                                        
          <p>Your dog {booking.dog.name} is booked for a walk!</p>                                                                                                                                                                         
        </div>                                                                                                                                                
      )}                                                                                                                                                
    </div>                                                                                                                                                
  )                                                                                                                                                
}
```

# 5. Write the server side function that runs when a user presses “book” (pseudocode is fine)

## *Actual implementation available [here](src/app/api/bookings/post.ts)*

### Outline:

**Serverless function to handle booking [POST /bookings]**

- Authenticate the user via their `Authorization` header token
- Get the requested date and the selected dog from the JSON `body`
- Check for conflicts to make sure that time slot has not been reserved already
- If there is a conflict, return the HTTP code 409 for “conflict”
- If there is no conflict, create a new booking in the database:
- Associate the booking with the authenticated User (as deciphered from the `Authorization` header)
- Associate the selected Dog with the booking (as passed in the request `body`)
- Set the booking date to the requested date (as passed in the request `body`)
- Return the successful booking

### Implementation:

```typescript
// api/post-booking.service.ts                                                                  
                                                                                       
export const handler = async (                                                                                                
  { userToken, body }: PostRequest                                                                                                
): Promise<Response> => {                                                                                                
  try {                                                                                                
    const { date, dogID } = JSON.parse(body)                                                                                                
                                                                                                
    // Check for conflicting booking                                                                                                
    const conflict = !!await prisma.booking.findFirst({                                                                                                
      where: { date, cancelled: false },                                                                                                
    })                                                                                                
                                                                                                
    if (conflict) throw {                                                                                                
      code: 409,                                                                                                
      message: 'This time has already been booked.',                                                                                                
    }                                                                                                
                                                                                                
    const booking = await prisma.booking.create({                                                                                                
      data: {                                                                                                
        user: {                                                                                                
          connect: { id: userToken.user_id },                                                                                                
        },                                                                                                
        date,                                                                                                
        dog: {                                                                                                
          connect: { id: dogID }                                                                                                 
        }                                                                                                                                                
      }                                                                                                
    })                                                                                                
                                                                                                
    return {                                                                                                
      statusCode: 200,                                                                                                
      data: booking,                                                                                                                                                                                                
    }                                                                                                
  } catch(err: any) {                                                                                                
    return {                                                                                                
      statusCode: 400,                                                                                                
      data: {                                                                                                
        error: err.code,                                                                                                
        message: err.message,                                                                                                
      },                                                                                                
    }                                                                                                
  }                                                                                                
}                                                                                                
```
